# linux kernel module, simple cached queue implementation with async swaping.
## Sample shows how to create a queue of any defined type using linked data.

Модуль ядра Linux, простая реализация очереди с асинхронным кэшем.

I. using linked data   ( ./kernel_mod/linked_data )
Пример показывает, как создать fifo с произвольным размером элементов, 
используя связанные данные.

Предполагается выполнение дополнительно двух примеров реализации FIFO, 
использующих асинхронный обмен с кэшем с применением макросов из linux/kfifo.h 
и linux/list.h, вместо использования связанных структур данных. 

Согласно задания 'task.txt' модуль хранит в оперативной памяти очередь 
произвольных сообщений до 64К каждое. Размер очереди ограничен 1024 
элементами. Модуль обеспечивает интерфейс push_back() и pop_front(), используя 
символьное устройство /dev/heap. Модуль выполняет обмен с файловой системой, 
обеспечивая синхронное сохранение/подкачку элементов очереди. Модуль 
обеспечивает интерфейс управления асинхронным сохранением/подкачкой некоторой 
части очереди, используя файловое имя /proc/heap_node - при записи 
положительного числа выполняется выгрузка данных в файловую систему:

    $ echo 17 > /proc/heap_node,
    
при указании отрицательного числа, выполняется подкачка данных в оперативную 
память:

    $ echo -3 > /proc/heap_node.
    
Операция чтения обеспечивает вывод информации о состоянии очереди:

    $ cat /proc/heap_node.

Управление асинхронным сохранением/подкачкой выполняется в отдельном потоке. 
Файловое хранилище располагается в /var/log/heap

Установка модуля:

    $ uname -r
    4.16.3-301.fc28.i686
    
    # mkdir -p /var/log/heap
    # make
    # insmod ./heap.ko
    
для установки может потребуется переключение SELinux в режим предупреждений

    # setenforce Permissive
    
проверка модуля:

    # echo qwerty > /dev/heap
    # cat /proc/heap_node
    HEAPSIZE 1024, heap entries 1, swap 0
    # cat /dev/heap
    qwerty
    # cat /proc/heap_node
    HEAPSIZE 1024, heap entries 0, swap 0

процедура удаления:
    
    # rmmod heap
    # setenforce Enforcing
    

II. Консольное приложение ( ./sender_app ) взаимодействует с модулем ядра, 
записывая произвольные сообщения размером до 64K в /dev/heap. Приложение 
принимает параметр командной строки, который задаёт количество отправляемых 
сообщений или генерирует одно сообщение:

    # ./sender 127


III. user-mode демон ( ./recipient_svc ) вычитывает сообщения из /dev/heap и 
помещает в файловое хранилище. Служба принимает параметр командной строки, 
который задаёт интервал ожидания ( в милисекундах ) после считывания:

    # ./recepient 100

Процесс перехватывает сигнал SIGTERM для корректного завершения операций 
ввода-вывода. SIGTERM для остановки демона:

    $ ps -A | grep recipient
    602 ?        00:00:08 recipient
    
    # kill 602

- в разработке ---------------------------------------------------------------

I.I. using kfifo macro   ( ./kernel_mod/kfifo_macro )
Пример показывает, как создать fifo с применением макросов linux/kfifo.h
.. в разработке

I.II. using list macro    ( ./kernel_mod/list_macro )
Пример показывает, как создать fifo с применением макросов linux/list.h.
.. в разработке

